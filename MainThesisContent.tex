\documentclass[bp,en]{FEIstyle}

\usepackage{mathtools}
\usepackage{ amssymb }
\usepackage{float}



\FEIauthor{Erik Ziman}
\FEItitle{Kryptografia na báze eliptických kriviek - analýza bezpečnosti a demonštrácia útokov}
\FEItitleEn{Elliptic curve cryptography - security analysis and attack demonstration}
\FEIregNr{FEI-UNKNOWN}
\FEIsupervisor{Mgr. Karina Chudá, PhD.}
%\FEIconsultant{Ing. John Doe}

\FEIkeywords{kľúčové slovo1, kľúčové slovo2, kľúčové slovo3}
\FEIkeywordsEn{keyword1, keyword2, keyword3}
% \FEIglossaries{includes/glossary}
\bibliography{includes/bibliography.bib}

\iffalse \input{includes/glossary} \fi



\newcommand{\point}[1]{
#1 = (x_{#1}, y_{#1})
}

\newcommand{\ycor}[1]{
y_{P_{#1}}
}

\newcommand{\xcor}[1]{
x_{P_{#1}}
}

\begin{document}
As Yale University professor Serge Lang once noted in the beginning of his book \textit{Elliptic Curves: Diophantine Analysis}, ``It is possible to write endlessly on elliptic curves. (This is not a threat)." Indeed, elliptic curves form a deep and intricate subject. In this thesis, we will dive into the topic of elliptic curves, with a particular focus on their impact in the field of modern cryptography. We aim to explore their significance and key properties, highlighting the crucial role they play in many cryptographic systems. The primary aim of this thesis is to deepen our understanding of this complex topic to such an extent that we are able to implement elliptic curve cryptography (ECC) in various applications and programs. In addition to exploring the theoretical significance of elliptic curves, we will also implement a few examples of elliptic curves referenced with corresponding source code and visual representation. Furthermore, this thesis will shed light on various attacks and common mistakes in the implementation of these curves, emphasizing the importance of secure and correct practices when building cryptographic applications.
\section*{Motivation for Using Elliptic Curves}
The main advantage of ECC is the degree of security it provides when considering its comparatively smaller key sizes.

\begin{table}[h]
    \centering
    \caption{Time to Break vs Key Sizes}
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Time to Break (MIPS-years)} & \textbf{ECC Key Size (bits)} & \textbf{RSA Key Size (bits)} \\
        \hline
        $10^4$  & 106   & 512  \\ \hline
        1$0^8$  & 132   & 768  \\ \hline
        $10^{11}$    & 160   & 1024   \\ \hline
        $10^{20}$    & 210   & 2048   \\ \hline
        $10^{78}$    & 600   & 21000  \\
        \hline
    \end{tabular}
\end{table}


With the keys being smaller, we are able to have better computational efficiency of the algorithms; thus, our requirements on hardware resources can lower. Another advantage is that almost all currently known systems based on the discrete logarithm problem can be converted into elliptic curve-based systems. The vast majority of elliptic curve cryptography schemes rely on the Elliptic Curve Discrete Logarithm Problem (ECDLP) for their security.
\section*{What is an Elliptic Curve?}
In order to start defining elliptic curves, we first need to introduce some terms up front.
\subsection*{Algebraic curve:}
An \textit{algebraic curve} (over field $K$) is set of points (x, y) in the plane that satisfy a a non-constant polynomial equation in two variables. A \textit{nonsingular algebraic curve} is algebraic curve without any singular points.
\[
A: = \{ (x,y) \in K^2 \mid f(x, y) = 0\}  
\]
% \subsection*{K-rational point:}
% A $K$-\textit{rational point} is a solution $(x, y)$ to the equation of an algebraic curve, where both $x$ and $y$ are in the field $K$.
\subsection*{K-rational point:}
A \( K \)-\textit{rational point} is a solution \( (x, y) \) to the equation of an algebraic curve, where both \( x \) and \( y \) are in the field \( K \). 

\[
\point{P} \quad \text{where } f(P) = 0 \text{ with } x_{P}, y_{P} \in K.
\]

\subsection*{Point at infinity:}
The point at infinity $\mathcal{O}$ is the identity element of elliptic curve arithmetic. Adding this point to any other point (including itself) results in that other point:
\[
\mathcal{O} + P = P 
\]
\[
\mathcal{O} + \mathcal{O} = \mathcal{O} 
\]
\subsection*{Elliptic curve:}
An \textit{elliptic curve} (over field $K$) is a nonsingular cubic curve, with at least 1 $K$-rational point. We will primarily be working with curves that are defined by The Weierstrass Form:
\[
E := \{ (x,y) \in K^2 \mid y^2 = x^3 + ax + b \} \cup \{ \mathcal{O} 
\} \quad \text{with } a, b \in K
\]
Elliptic curve is considered to form a group if it's cubic polynomial, has no repeated roots.
\newpage

\subsection*{Examples over $\mathbb{R}$:}
\begin{figure}[H]
    \centering
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{img/curve__y^2_=_x^3_+4.png}
        \caption{$y^2 = x^3 + 4$}
        \label{fig:example_curve_1}
    \end{subfigure}%
    \hfill % Add horizontal space between figures
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{img/curve__ y^2_=_x^3_-2x_+_3.png}
        \caption{$y^2 = x^3 - 2x + 3$}
        \label{fig:example_curve_2}
    \end{subfigure}%
    \hfill % Add horizontal space between figures
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{img/curve__y^2_=_x^3_-5x_+2.png}
        \caption{$y^2 = x^3 - 5x + 2$}
        \label{fig:example_curve_3}
    \end{subfigure}
    \caption{Elliptic curves (over $\mathbb{R}$)}
    \label{fig:example_elliptic_curves_1}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\linewidth]{img/curve_finite_y2=x3-x+3.png}
        \caption{$y^2=x^3-x+3 \mod 97$}
        \label{fig:example_curve_4}
    \end{subfigure}%
    \begin{subfigure}{0.4841\textwidth}
        \includegraphics[width=\linewidth]{img/curve_finite-y2=x3-x-3.png}
        \caption{$y^2=x^3-x-3 \mod 47$}
        \label{fig:example_curve_5}
    \end{subfigure}%
    \caption{Elliptic curves (over finite fields)}
    \label{fig:example_elliptic_curves_2}
\end{figure}
% First, we are going to give a few examples over the field $\mathbb{R}$, then (for reasons that will be explained later), we are going to focus more on analyzing curves over finite fields.
\newpage
\section*{Operations on Elliptic Curves}
Now that we know what an elliptic curve is, let's define the operational rules for performing point calculations on these curves. \\
$E := \{ (x,y) \in K^2 \mid y^2 = x^3 + ax + b \} \cup \{ \mathcal{O} 
\} \quad \text{with } a, b \in K$ \\ 
$\point{P_i}$ with $P_i \in E$
\subsection*{Negating a point:}
\[ 
P = (x_P, y_P) 
\]
\[ 
-P = -(x_P, y_P) = (x_P, - y_P)
\]
\begin{figure}[H]
    \centering
    \begin{subfigure}{0.4\textwidth}
        \includegraphics[width=\linewidth]{img/negating_point.png}
        \label{fig:negating_point_curve_1}
    \end{subfigure}%
    \begin{subfigure}{0.4255\textwidth}
        \includegraphics[width=\linewidth]{img/negating_point_finite.png}
        \label{fig:negating_point_curve_2}
    \end{subfigure}%
    \caption{Visual representation of point negation }
    \label{fig:negating_point_curves}
\end{figure}
% Notice how $P$ and $-P$ are inverse to each other.
\subsection*{Finding inverse of a point:}
\[ 
P = (x_P, y_P) 
\]
\[ 
P^{-1} = -P 
\]
\subsection*{Addition:}
Addition is commutative meaning $P_i + P_j = P_j + P_i$. \\
In these examples below we asume that $P_3 = P_1 + P_2$\\
\text{ 1.) if } $P_1 \neq P_2$ and $P_1,P_2 \neq \mathcal{O} $:
\[
\lambda = \frac{y_{P_2} - y_{P_1}}{x_{P_2} - x_{P_1}}
\]
\[
P_3 = (\lambda^2 - x_{P_1} - x_{P_2}\text{ , } \lambda(x_{P_1} - x_{P_3}) - y_{P_1})
\]
\begin{figure}[H]
    \centering
    \begin{subfigure}{0.38\textwidth}
        \includegraphics[width=\linewidth]{img/addition_ecc.png}
        \label{fig:addition_curve_1}
    \end{subfigure}%
    \begin{subfigure}{0.412\textwidth}
    
        \includegraphics[width=\linewidth]{img/finite_addition.png}
        \label{fig:addition_curve_2}
    \end{subfigure}%
    \caption{Visual representation of point addition (case 1)}
    \label{fig:addition_elliptic_curves_1}
\end{figure}


\text{2.) if } $P_1 = P_2$  and $y_{P_1},\ycor{2} \neq 0$ and $P_1,P_2 \neq \mathcal{O} $: \par
\[
m = \frac{3x_{P_1}^2 + a}{2y_{P_1}}
\]
\[
P_3 = (m^2 - 2{x_{P1}}\text{ , } m(x_{P_1} - x_{P_3}) - y_{P_1})
\]
\begin{figure}[H]
    \centering
    \begin{subfigure}{0.38\textwidth}
        \includegraphics[width=\linewidth]{img/addition_tangent.png}
        \label{fig:addition_curve_3}
    \end{subfigure}%
    \begin{subfigure}{0.42\textwidth}
        \includegraphics[width=\linewidth]{img/tangent_finite_last.png}
        \label{fig:addition_curve_4}
    \end{subfigure}%
    \caption{Visual representation of point addition (case 2)}
    \label{fig:addition_elliptic_curves_2}
\end{figure}


\text{3.) if } $P_1 = P_2$  and $\ycor{1},\ycor{2} = 0$ \par
\[
P_3 = \mathcal{O} 
\]
\begin{figure}[ht]
    \centering
    \begin{subfigure}{0.4\textwidth}
        \includegraphics[width=\linewidth]{img/addition_same_point_2.png}
        \label{fig:addition_curve_5}
    \end{subfigure}%
    \begin{subfigure}{0.405\textwidth} 
        \includegraphics[width=\linewidth]{img/infinity_addition.png}
        \label{fig:addition_curve_6}
    \end{subfigure}%
    \caption{Visual representation of point addition (case 3)}
    \label{fig:addition_elliptic_curves_3}
\end{figure}
\text{4.) if } $P_1 \neq \mathcal{O}$ , $P_2 = \mathcal{O}$  \par
\[
P_3 = P_1 
\]

\text{5.) if } $P_1 = -P_2$ 
\[
P_3 = \mathcal{O}
\]
\subsection*{Subtraction:}
\[
P_1 - P_2 = P_1 + (-P_2)
\]
\[ 
(x_{P_1}, y_{P_1}) - (x_{P_2}, y_{P_2}) = (x_{P_1}, y_{P_1}) + (x_{P_2}, -y_{P_2})
\]
\subsection*{Multiplication:}
Only scalar multiplication is possible. By multiplication, we understand repeated addition of point to itself.
\[
k\times P = P + P + ... \text{ } k \text{ times }
\] % \textit{Note:} For slope calculation use the formula when $P = Q$.
% \subsection*{Division:}
% Only scalar division is possible. 
% \[
% \frac{1}{a} (x_p, y_p) = a^{-1} (x_p, y_p)
% \]



\subsubsection*{Larger multiples of points:}
This works well in theory but what if $k$ was a really large number? It is obvious that in order to implement secure elliptic curve based algorithms, we will need to work with big multiples of points. The faster we can get to the result, the better. There is a number of techniques which can help us achieve faster computation of these big point multiplications.


\subsubsection*{Double and add method:}
We already know that elliptic curves form a group over finite field $\mathbb{F}_\mathbb{P}$ considering $P$ is a non-even prime. This means that whenever we add any of the two members of this group together the result will also have to be a member of this group. For example:
\[
3 \times P + 9 \times P = 12 \times P
\]
As we saw in this example (TODO add reference to tangent point addition) adding a point $P_1$ to $P_2$ is being calculated the same way as adding $P_1$ to itself (assuming $P_1=P_2$). Since $P_1+P_1=2\times P_1$, adding a point to itself is the same operation as doubling the point. Now we have effective way for doubling a point using simple addition. 

We can leverage this by taking $k_2$ and start progressively doubling P as many times as there are binary digits from least significant bit (LSB) up to most significant "1" bit. For each "1" bit in $k$'s binary form, we add the corresponding multiple of 2 $\times$ P to the accumulated result. Here's an example:

\[
41 \times P 
\]
\[
41_{10} = 110011_2  
\]
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Bits of 41} & \textbf{Current Doubling} & \textbf{Result (After Addition if bit = 1)} \\ \hline
1 & $P$ & $P$ \\ \hline
1 & $2\times P$ & $P+2\times P=3\times P$ \\ \hline
0 & $4\times P$ & $3\times P$ \\ \hline
0 & $8\times P$ & $3\times P$ \\ \hline
1 & $16\times P$ & $3\times P+16\times P=19\times P$ \\ \hline
1 & $32\times P$ & $19\times P+32\times P=41\times P$ \\ \hline
\end{tabular}
\caption{Binary Representation and Double-and-Add Method for $41 \times P$}\end{table}




This computation uses $log_2(n)$ multiplications and on average $\frac{1}{2}log_2(n)$ additions. 


\newpage

\begin{algorithm}
\caption{Double and add algorithm for point multiplication }  
\label{alg:double-and-add-safer}                         
\begin{algorithmic}[1]                    
    \STATE $P_3 = \mathcal{O}$
    \STATE $P_2 = P_1$ 
    \WHILE{$k > 0$}
        \IF{$k \bmod 2 = 1$} 
            \STATE $P_3= P_3 + P_2$ 
        \ENDIF
        \STATE $P_2 = 2 \times P_2$ 
        \STATE $k >> 1$
    \ENDWHILE
    \RETURN $P_3$
\end{algorithmic}
\end{algorithm}
If we don't limit ourselves to  binary representation of a number $k$ we are able to optimize the computing time and resources even further by converting number $k$ in to balanced ternary numeral system which uses coefficients \{-1,0,1\}. Subtraction has same complexity as addition since it is the same operation with a twist of negating y coordinate. 

\newpage

\section*{Elliptic Curves over finite field}

\subsection*{Order of EC}
Order of EC over finite field is equal to number of points on this curve + point at infinity $\mathcal{O}$. We mark order of EC to be $n$.

\subsection*{Generator point of EC subgroups}
Generator point $G_S$ of a subgroup $S$ is a point on EC, which can generate any other point in $S$. We can generate all elements of $S$ by multiplying $G_S$ by all elements of $\langle 0,r-1\rangle $ where $r$ is the order of $S$. In cases where $S$ contains all points of EC, $G$ generates all points of EC.

\subsection*{Subgroups formed by EC}
Points on EC over finite field can form one or more finite cyclic subgroups. There are cases when EC will generate only one subgroup which is of same order as the EC itself ($n$). If EC forms multiple subgroups, it is given that these subgroups are all non-overlapping and cyclic. Sum of the orders of these subgroups + point at infinity $\mathcal{O}$ must be equal to order of the EC. 

\subsection*{Cofactor of EC}
Cofactor is equal to number of subgroups formed by EC. We mark cofactor of EC to be $h$


% \begin{figure}[H] 
%     \centering
%     \includegraphics[width=0.9\textwidth]{EC_subgroups.png} 
%     \caption{EC subgroups}
%     \label{fig:example-image}
% \end{figure}

\subsection*{Point compression and decompression}
When working with EC over finite field, we can observe that to every $x$ coordinate there are at most 2 corresponding $y$ coordinates. One of these is guaranteed to be odd and the other one to be even. We can use this information to further narrow down our requirements on storing these points in computer memory by just saving the $x$ coordinate and the parity of $y$ coordinate (we only need 1 bit for this). Then to decompress such point we need to calculate these two formulas and then chose the coordinate with correct parity: \\
    $y_1 = \sqrt{x^3 + ax + b} \mod p$\\ $y_2 = - y_1 \mod p$
\newpage

\section*{EC in key exchange mechanisms:}

\subsection*{Discrete logarithm problem DLP:}

DLP is a "one-way" problem area in mathematics which considers the following qualities of modular arithmetic combined with exponential functions:\\
- It relatively easy to compute $a^b \mod{p}$ when given a, b and p\\
- However, finding b when given a and p is much harder task\\ 
This asymmetry is fundemental DLP concept and it is one of the key 
elements which many cryptographic protocols use when relying on complexity of this problem.


\subsection*{Primitive root:}
If $g$ is primitive root of $p$, then the powers $g^1,g^2…,g^{p - 1}$ $\mod$ p, will produce all the integers congruent to numbers from 1 to p -1 in some order.


\subsection*{Diffie-Hellman key exchange DH:}

Diffie-Hellman key exchange is a key exchange protocol that lets you generate a shared secret key over which all of your communication will be encrypted without the need to share this secret ahead of time. DH leverages the difficulty of the DLP. Imagine we have two Participants, let's call them Participant A and Participant B. We want for these participants to have safe and encrypted communication. In order to achieve this they will need some sort of symmetric encryption algorithm to be used on both sides and a shared secret key which will be used on encrypting and decrypting data they send to each other. These participants have never exchanged any information before so they don't have the ability to have shared secret key communicated upfront. This is where DH comes in. DH can be decoupled into 5 steps:

\subsubsection*{Step 1}
Participants agree on large prime number $p$ and it's primitive root $g$. Note that this information can be shared over insecure communication channel.

\subsubsection*{Step 2}
Participants generate their private keys (for example by using random number generator) and compute their respective public keys followingly:

\[
\text{Secret key of participant A} = a \text{, Secret key of participant B} = b
\]
\[
a=random(), b=random()
\]
\[
\text{Public key of participant A} = A \text{, Public key of participant B} = B
\]
\[
A= g^a\mod p ,\text{ }B= g^b\mod p
\]

\subsubsection*{Step 3}
Participants share their public keys A and B with one another. Note this can also be done over insecure communication channel.

\subsubsection*{Step 4}
Now it's time to calculate secret shared key $S$. 
\[
\text{Shared key for participant A }= S_A\text{, Shared key for participant B }= S_B
\]
\[
S_A=B^a\mod p, \text{ }S_B=A^b\mod p 
\]
\[
S_A=S_B 
\]


\subsubsection*{Step 5}
Use S for encrypting and decrypting shared content 

\subsubsection*{Visual example of DH}
\begin{table}[h!]
\centering
\small % Reduces font size for the table
\begin{tabular}{|p{1cm}|p{5cm}|p{5cm}|} % Defines column widths to allow text wrapping
\hline
\textbf{Steps} & \textbf{Participant A} & \textbf{Participant B} \\ \hline
\textbf{1} & \multicolumn{2}{p{10cm}|}{Agree on a large prime number \( p \) and it's primitive root \( g \) } \\ \hline
\textbf{2} & Generates private key \( a \) & Generates private key \( b \)  \\ \hline
\textbf{3} & Calculates \( A = g^a \mod p \) and sends \( A \) to participant B & Calculates \( B = g^b \mod p \) and sends \( B \) to participant A \\ \hline
\textbf{4} & Receives \( B \)  and calculates \( S_A = B^a \mod p \) & Receives \( A \)  and calculates \( S_B = A^b \mod p \) \\ \hline
\textbf{5} & \multicolumn{2}{p{10cm}|}{Use \(S_A\) and \(S_B\) for encrypting and decrypting data } \\ \hline
\end{tabular}
\caption{Diffie-Hellman Key Exchange Process}
\label{tab:diffie_hellman}
\end{table}


\subsubsection*{How does DH work?}
Modulo operation is distributive. When we use it on expanded forms of $S_A$ and $S_B$ we can see:
\[S_A=S_B
\]
\[
(g^b \mod p)^a \mod p = (g^a \mod p)^b \mod p
\]
\[
g^{ba} \mod p = g^{ab} \mod p
\]

\subsection*{Elliptic Curve Discrete Logarithm Problem ECDLP:}
ECDLP is a transformation of a classic DLP problem taken from a perspective of EC. When talking about ECDLP we take $E$ to be an elliptic curve over finite field with order $n$. Let $P$ and $Q$ to be points on $E$. ECDLP leverages these facts:\\
- It is relatively easy to compute $Q$ as a result of $c\times P$ when given $c$ and $P$ \\
- However, finding $c$ ($0\leq c \leq n-1$) when given only $P$ and $Q$ is much harder task
\subsection*{Elliptic Curve Diffie-Hellman key exchange ECDH:}
ECDH is a transofmation of DH key exchange algorithm, which uses EC point multiplication instead of modular exponentiations. When transforming DH into ECDH we take G as a generator point of sufficiently large cyclic sub-group of all points generated by E. This G will then first be multiplied by private keys of participants A and B (generation of their public keys) and then after they share the public keys with one another, those public keys will be multiplied once again with their own private key.
\subsubsection*{Visual example of ECDH}
\begin{table}[h!]
\centering
\small % Reduces font size for the table
\begin{tabular}{|p{1cm}|p{5cm}|p{5cm}|} % Defines column widths to allow text wrapping
\hline
\textbf{Steps} & \textbf{Participant A} & \textbf{Participant B} \\ \hline
\textbf{1} & \multicolumn{2}{p{10cm}|}{Agree on definition of curve \(E\) and generator point \( G\)} \\ \hline
\textbf{2} & Generates private key \( a \) & Generates private key \( b \)  \\ \hline
\textbf{3} & Calculates \( A = a\times G \) and sends \( A \) to participant B & Calculates \( B = b\times G \) and sends \( B \) to participant A \\ \hline
\textbf{4} & Receives \( B \)  and calculates \( S_A = a\times B  \) & Receives \( A \)  and calculates \( S_B = b\times A  \) \\ \hline
\textbf{5} & \multicolumn{2}{p{10cm}|}{Use \(S_A\) and \(S_B\) for encrypting and decrypting data } \\ \hline
\end{tabular}
\caption{Elliptic Curve Diffie-Hellman Key Exchange Process}
\label{tab:diffie_hellman}
\end{table}

\newpage


\section*{Attacks on EC}

\subsection*{Chinese remainder theorem}
Suppose we have numbers $m_1,m_2,...,m_n$ that are pairwise coprime. Then the system of n equations: 
\[
x = a_1 \mod m_1
\]
\[
x = a_2 \mod m_2
\]
\[
...
\]
\[
x = a_n \mod m_n
\]
\[
M=m_1*m_2*...*m_n 
\]
has a unique solution for $x \mod M$ 
\[
M_i = \frac{M}{m_i}
\]
\[
x = \sum_{i=1}^{n} a_i*M_i*M_i^{-1}\mod M
\]
\subsection*{Not verifying that a point is on EC}
Let's say that we are communicating with someone and we were really careful about which specific curve definition we should use, meaning our agreed curve $E$ and it's respective generator point $P$ is part of a subgroup with high enough order, that anybody who is trying to brute-force their way over our whole possible private key space doesn't stand a chance. If we take a better look at formula of addition on EC, we can notice that for such computations, we only need the value of $a$ and $p$, but never $b$ (taken from formula of general EC definition). Now let's consider a scenario where if received generator point $P$ or for example public key of other participant, we would not bother to check if this $P$ actually exists on our EC $E$. This means that theoretically someone could use this to their advantage and send us point $P$ which is on his malicious curve $E'$ instead of our $E$ and forms subgroup with a lot smaller order than our carefully picked curve $E$. Since we don't check if $P$ is part of $E$, we happily compute the multiplication process for $P$ on $E'$ and then share the result point with our attacker. How can attacker create such malicious curve? Answer is simple. He just needs to modify $b$ coefficient until he finds such curve $E'$ which forms subgroup of his desired order. Now let's say that he will generate as many malicious $E's$ and $Ps$ as he needs to in order to reveal how many operations does it take to get to the point $a\times P \mod r$ where $r$ is order of his malicious subgroup and $a$ is our private key. When attacker gets to a point where he has generated as many $E's$ and $Ps$ as he needed in order to reveal our true $a$ he can simply just use Chinese remainder theorem to tell him.   

\end{document}